<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MiniCPM-o Demo</title>
<style>
  :root { --bg: #1a1a2e; --card: #16213e; --accent: #e94560; --text: #eee; --muted: #888; }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
         background: var(--bg); color: var(--text); min-height: 100vh;
         display: flex; flex-direction: column; align-items: center; padding: 2rem; }
  h1 { font-size: 1.5rem; margin-bottom: 1.5rem; font-weight: 500; }
  .container { width: 100%; max-width: 600px; }

  /* çŠ¶æ€æ  */
  #status { text-align: center; color: var(--muted); font-size: 0.9rem; margin-bottom: 1rem; min-height: 1.2em; }

  /* æŒ‰é’® */
  .btn-wrap { display: flex; justify-content: center; margin-bottom: 1.5rem; gap: 0.8rem; flex-wrap: wrap; }
  button { background: var(--card); color: var(--text); border: 1px solid #333;
           padding: 0.7rem 1.5rem; border-radius: 8px; cursor: pointer; font-size: 0.95rem;
           transition: all 0.15s; }
  button:hover { border-color: var(--accent); }
  button:active { transform: scale(0.97); }
  button:disabled { opacity: 0.4; cursor: not-allowed; }
  button.recording { background: var(--accent); border-color: var(--accent); animation: pulse 1s infinite; }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.7; } }

  /* å¯¹è¯åŒº */
  .chat { background: var(--card); border-radius: 12px; padding: 1.2rem; min-height: 200px;
          max-height: 60vh; overflow-y: auto; white-space: pre-wrap; line-height: 1.6;
          font-size: 0.95rem; margin-bottom: 1rem; }
  .chat .user { color: #4fc3f7; margin-bottom: 0.3rem; }
  .chat .assistant { color: var(--text); margin-bottom: 0.8rem; }
  .chat .system { color: var(--muted); font-size: 0.85rem; font-style: italic; margin-bottom: 0.5rem; }

  /* ç»Ÿè®¡ */
  .stats { display: flex; gap: 1.5rem; justify-content: center; color: var(--muted); font-size: 0.85rem; }
  .stats span { background: var(--card); padding: 0.4rem 0.8rem; border-radius: 6px; }
</style>
</head>
<body>

<h1>MiniCPM-o è¯­éŸ³å¯¹è¯</h1>
<div class="container">
  <div id="status">ç‚¹å‡»ã€Œå½•éŸ³ã€å¼€å§‹å¯¹è¯</div>

  <div class="btn-wrap">
    <button id="btnRecord">ğŸ™ï¸ å½•éŸ³</button>
    <button id="btnStop" disabled>â¹ï¸ å‘é€</button>
    <button id="btnAbort" disabled style="background:var(--accent);border-color:var(--accent);">âœ‹ æ‰“æ–­</button>
    <button id="btnReset">ğŸ”„ æ–°å¯¹è¯</button>
  </div>
  <div style="display:flex;align-items:center;justify-content:center;gap:0.6rem;margin-bottom:1rem;font-size:0.85rem;color:var(--muted);">
    <label for="lpSlider">length_penalty:</label>
    <input id="lpSlider" type="range" min="0.8" max="2.0" step="0.05" value="1.1" style="width:120px;">
    <span id="lpValue">1.1</span>
  </div>

  <div class="chat" id="chat"></div>

  <div class="stats">
    <span>é¦–å“: <b id="statTTFA">-</b></span>
    <span>éŸ³é¢‘: <b id="statAudio">-</b></span>
    <span>RTF: <b id="statRTF">-</b></span>
  </div>
</div>

<script>
const API = '';
const RECORD_SAMPLE_RATE = 16000;
const PLAYBACK_SAMPLE_RATE = 24000;

// DOM
const $ = (id) => document.getElementById(id);
const $status = $('status');
const $chat   = $('chat');
const $btnRec = $('btnRecord');
const $btnStp = $('btnStop');
const $btnRst = $('btnReset');
const $btnAbort = $('btnAbort');
const $ttfa   = $('statTTFA');
const $audio  = $('statAudio');
const $rtf    = $('statRTF');

const $lpSlider = $('lpSlider');
const $lpValue  = $('lpValue');
$lpSlider.addEventListener('input', () => { $lpValue.textContent = $lpSlider.value; });

let mediaStream = null;
let audioCtx = null;
let playbackCtx = null;
let recorder = null;
let recordedChunks = [];
let isRecording = false;
let isGenerating = false;
let abortController = null;

// ==================== åˆå§‹åŒ–å¼•æ“ ====================
async function initEngine() {
  $status.textContent = 'åˆå§‹åŒ–å¼•æ“ä¸­...';
  try {
    const resp = await fetch(`${API}/omni/init_sys_prompt`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ media_type: 1, duplex_mode: false, language: 'zh', length_penalty: parseFloat($lpSlider.value) }),
    });
    const data = await resp.json();
    if (data.success) {
      $status.textContent = 'å¼•æ“å°±ç»ªï¼Œå¯ä»¥å½•éŸ³';
    } else {
      $status.textContent = `åˆå§‹åŒ–å¤±è´¥: ${JSON.stringify(data)}`;
    }
  } catch (e) {
    $status.textContent = `åˆå§‹åŒ–å¼‚å¸¸: ${e.message}`;
  }
}

async function checkHealth() {
  try {
    const resp = await fetch(`${API}/health`);
    const data = await resp.json();
    if (data.initialized) {
      $status.textContent = 'å¼•æ“å°±ç»ªï¼Œå¯ä»¥å½•éŸ³';
    } else {
      await initEngine();
    }
  } catch (e) {
    $status.textContent = `è¿æ¥å¤±è´¥: ${e.message}`;
  }
}

// ==================== é‡ç½®å¯¹è¯ ====================
async function resetConversation() {
  if (isGenerating) return;
  $btnRst.disabled = true;
  try {
    const resp = await fetch(`${API}/omni/reset`, { method: 'POST' });
    const data = await resp.json();
    if (data.success) {
      $chat.innerHTML = '';
      appendChat('system', 'â€” æ–°å¯¹è¯ â€”');
      $ttfa.textContent = '-';
      $audio.textContent = '-';
      $rtf.textContent = '-';
      $status.textContent = 'å¯¹è¯å·²é‡ç½®ï¼Œå¯ä»¥å½•éŸ³';
    } else {
      $status.textContent = `é‡ç½®å¤±è´¥: ${JSON.stringify(data)}`;
    }
  } catch (e) {
    $status.textContent = `é‡ç½®å¼‚å¸¸: ${e.message}`;
  }
  $btnRst.disabled = false;
}

// ==================== å½•éŸ³ (16kHz mono 16bit WAV) ====================
async function startRecording() {
  if (isRecording || isGenerating) return;
  recordedChunks = [];

  try {
    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: { sampleRate: RECORD_SAMPLE_RATE, channelCount: 1, echoCancellation: true }
    });
  } catch (e) {
    $status.textContent = `éº¦å…‹é£æƒé™è¢«æ‹’ç»: ${e.message}`;
    return;
  }

  audioCtx = new AudioContext({ sampleRate: RECORD_SAMPLE_RATE });
  const source = audioCtx.createMediaStreamSource(mediaStream);
  recorder = audioCtx.createScriptProcessor(4096, 1, 1);
  recorder.onaudioprocess = (e) => {
    const data = e.inputBuffer.getChannelData(0);
    recordedChunks.push(new Float32Array(data));
  };
  source.connect(recorder);
  recorder.connect(audioCtx.destination);

  isRecording = true;
  $btnRec.classList.add('recording');
  $btnRec.disabled = true;
  $btnStp.disabled = false;
  $btnRst.disabled = true;
  $status.textContent = 'å½•éŸ³ä¸­...';
}

function stopRecording() {
  if (!isRecording) return;
  isRecording = false;
  recorder.disconnect();
  mediaStream.getTracks().forEach(t => t.stop());
  audioCtx.close();

  $btnRec.classList.remove('recording');
  $btnStp.disabled = true;

  const totalLen = recordedChunks.reduce((s, c) => s + c.length, 0);
  const merged = new Float32Array(totalLen);
  let offset = 0;
  for (const chunk of recordedChunks) {
    merged.set(chunk, offset);
    offset += chunk.length;
  }

  const wavBytes = encodeWAV(merged, RECORD_SAMPLE_RATE);
  const wavB64 = arrayBufferToBase64(wavBytes);

  $status.textContent = `å½•éŸ³ ${(totalLen / RECORD_SAMPLE_RATE).toFixed(1)}sï¼Œå‘é€ä¸­...`;
  sendAndGenerate(wavB64);
}

function encodeWAV(samples, sampleRate) {
  const buffer = new ArrayBuffer(44 + samples.length * 2);
  const view = new DataView(buffer);
  const writeStr = (off, str) => { for (let i = 0; i < str.length; i++) view.setUint8(off + i, str.charCodeAt(i)); };
  writeStr(0, 'RIFF');
  view.setUint32(4, 36 + samples.length * 2, true);
  writeStr(8, 'WAVE');
  writeStr(12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * 2, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);
  writeStr(36, 'data');
  view.setUint32(40, samples.length * 2, true);
  for (let i = 0; i < samples.length; i++) {
    let s = Math.max(-1, Math.min(1, samples[i]));
    view.setInt16(44 + i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  return buffer;
}

function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

// ==================== Prefill + Generate ====================
async function sendAndGenerate(wavB64) {
  const t0 = performance.now();
  isGenerating = true;
  abortController = new AbortController();
  $btnRec.disabled = true;
  $btnRst.disabled = true;
  $btnAbort.disabled = false;

  appendChat('user', 'ğŸ™ï¸ [è¯­éŸ³è¾“å…¥]');

  try {
    // 1. Prefill
    $status.textContent = 'Prefill ä¸­...';
    const prefillResp = await fetch(`${API}/omni/streaming_prefill`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ audio: wavB64, idx: 0 }),
    });
    const prefillData = await prefillResp.json();
    if (!prefillData.success) {
      $status.textContent = `Prefill å¤±è´¥: ${JSON.stringify(prefillData)}`;
      isGenerating = false;
      $btnRec.disabled = false;
      $btnRst.disabled = false;
      return;
    }

    // 2. Generate (SSE)
    $status.textContent = 'ç”Ÿæˆä¸­...';
    const genResp = await fetch(`${API}/omni/streaming_generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ length_penalty: parseFloat($lpSlider.value) }),
      signal: abortController.signal,
    });
    const reader = genResp.body.getReader();
    const decoder = new TextDecoder();

    // æ’­æ”¾çŠ¶æ€
    if (!playbackCtx || playbackCtx.state === 'closed') {
      playbackCtx = new AudioContext({ sampleRate: PLAYBACK_SAMPLE_RATE });
    }
    if (playbackCtx.state === 'suspended') {
      await playbackCtx.resume();
    }

    let nextPlayTime = playbackCtx.currentTime;
    let totalAudioDur = 0;
    let firstAudioTime = null;
    let assistantText = '';
    const assistantEl = appendChat('assistant', '');

    let sseBuffer = '';
    let streamDone = false;

    // è¯» SSE æµ
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      sseBuffer += decoder.decode(value, { stream: true });

      while (sseBuffer.includes('\n\n')) {
        const idx = sseBuffer.indexOf('\n\n');
        const block = sseBuffer.substring(0, idx);
        sseBuffer = sseBuffer.substring(idx + 2);

        for (const line of block.split('\n')) {
          if (!line.startsWith('data: ')) continue;
          const payload = line.substring(6);

          // [DONE] æ ‡è®°
          if (payload === '[DONE]') {
            streamDone = true;
            break;
          }

          try {
            const data = JSON.parse(payload);

            // Text event
            if (data.chunk_data && data.chunk_data.text) {
              assistantText += data.chunk_data.text;
              assistantEl.textContent = assistantText;
              $chat.scrollTop = $chat.scrollHeight;
            }

            // Audio event
            if (data.chunk_data && data.chunk_data.wav) {
              if (!firstAudioTime) firstAudioTime = performance.now();
              const pcmBytes = atob(data.chunk_data.wav);
              const int16 = new Int16Array(pcmBytes.length / 2);
              for (let i = 0; i < int16.length; i++) {
                int16[i] = pcmBytes.charCodeAt(i * 2) | (pcmBytes.charCodeAt(i * 2 + 1) << 8);
              }
              const float32 = new Float32Array(int16.length);
              for (let i = 0; i < int16.length; i++) {
                float32[i] = int16[i] / 32768.0;
              }

              const audioBuf = playbackCtx.createBuffer(1, float32.length, PLAYBACK_SAMPLE_RATE);
              audioBuf.getChannelData(0).set(float32);
              const src = playbackCtx.createBufferSource();
              src.buffer = audioBuf;
              src.connect(playbackCtx.destination);

              const now = playbackCtx.currentTime;
              if (nextPlayTime < now) nextPlayTime = now;
              src.start(nextPlayTime);
              nextPlayTime += audioBuf.duration;
              totalAudioDur += audioBuf.duration;
            }
          } catch (e) { /* ignore parse errors */ }
        }
      }
    }

    // SSE æµç»“æŸï¼Œä½†éŸ³é¢‘å¯èƒ½ä»åœ¨æ’­æ”¾ä¸­
    // æ›´æ–°ç»Ÿè®¡ï¼ˆä½¿ç”¨ SSE ç»“æŸæ—¶é—´ä½œä¸º wall timeï¼‰
    const tStreamEnd = performance.now();
    const ttfa = firstAudioTime ? ((firstAudioTime - t0) / 1000).toFixed(1) : '-';
    $ttfa.textContent = `${ttfa}s`;
    $audio.textContent = `${totalAudioDur.toFixed(1)}s`;

    // ç­‰å¾…éŸ³é¢‘æ’­æ”¾å®Œæ¯•
    const remainingPlayTime = nextPlayTime - playbackCtx.currentTime;
    if (remainingPlayTime > 0) {
      $status.textContent = `æ’­æ”¾ä¸­... å‰©ä½™ ${remainingPlayTime.toFixed(1)}s`;
      await new Promise(resolve => setTimeout(resolve, remainingPlayTime * 1000));
    }

    const tEnd = performance.now();
    const wallTime = (tStreamEnd - t0) / 1000;
    const rtf = totalAudioDur > 0 ? (wallTime / totalAudioDur).toFixed(2) : '-';
    $rtf.textContent = rtf;
    $status.textContent = `å®Œæˆ | ç”Ÿæˆ ${wallTime.toFixed(1)}s | éŸ³é¢‘ ${totalAudioDur.toFixed(1)}s`;

  } catch (e) {
    if (e.name === 'AbortError') {
      $status.textContent = 'å·²æ‰“æ–­';
      appendChat('system', '[ç”¨æˆ·æ‰“æ–­]');
    } else {
      $status.textContent = `é”™è¯¯: ${e.message}`;
    }
  }

  abortController = null;
  isGenerating = false;
  $btnRec.disabled = false;
  $btnRst.disabled = false;
  $btnAbort.disabled = true;
}

// ==================== Chat UI ====================
function appendChat(role, text) {
  const el = document.createElement('div');
  el.className = role;
  el.textContent = text;
  $chat.appendChild(el);
  $chat.scrollTop = $chat.scrollHeight;
  return el;
}

// ==================== æ‰“æ–­ ====================
async function abortGeneration() {
  if (!isGenerating) return;
  // 1. é€šçŸ¥ C++ åœæ­¢æ¨ç†
  try { await fetch(`${API}/omni/stop`, { method: 'POST' }); } catch (_) {}
  // 2. ä¸­æ–­ SSE æµ
  if (abortController) abortController.abort();
  // 3. åœæ­¢éŸ³é¢‘æ’­æ”¾
  if (playbackCtx && playbackCtx.state !== 'closed') {
    try { await playbackCtx.close(); } catch (_) {}
    playbackCtx = null;
  }
}

// ==================== Events ====================
$btnRec.addEventListener('click', startRecording);
$btnStp.addEventListener('click', stopRecording);
$btnAbort.addEventListener('click', abortGeneration);
$btnRst.addEventListener('click', resetConversation);

// é¡µé¢åŠ è½½æ—¶æ£€æŸ¥
checkHealth();
</script>

</body>
</html>
